# Roadmap: Изучение Низкоуровневого Программирования

Этот roadmap описывает шаги для погружения в мир низкоуровневого программирования. Он структурирован по этапам с указанием последовательности, возможностей для параллельного изучения и специализаций.

## Содержание:

*   [[#Этап 0: Абсолютные Основы|Этап 0: Основы Компьютера]]
*   [[#Этап 1: Язык C - Фундамент|Этап 1: Изучение C]]
*   [[#Этап 2: Углубление в Память и Отладка в C|Этап 2: Память и Отладка в C]]
*   [[#Этап 3: Введение в Ассемблер и Архитектура CPU|Этап 3: Ассемблер и Архитектура CPU]]
*   [[#Этап 4: Основы Операционных Систем|Этап 4: Введение в ОС]]
*   [[#Этап 5: C++ для Системного Программирования|Этап 5: C++ (Специализация)]]
*   [[#Этап 6: Встроенные Системы и Аппаратное Взаимодействие|Этап 6: Embedded (Специализация)]]
*   [[#Этап 7: Дополнительные и Смежные Темы|Этап 7: Дополнительные Темы]]
*   [[#Этап 8: Практика, Проекты и Чтение Кода|Этап 8: Практика (Постоянно)]]

---

## Этапы Изучения:

### Этап 0: Абсолютные Основы
[[Этап 0 - Основы Компьютера]] 

`[Ядро/Последовательно]`

Это **первый и обязательный** этап. Без этих основ дальнейшее будет непонятно.
*   **Понятия:** Двоичная, Шестнадцатеричная системы. Понимание байтов, битов. Как представляются числа (целые, дробные).
*   **Архитектура:** Базовая модель компьютера (CPU, Память, Шины), регистры (очень кратко на этом этапе), принцип выполнения инструкций (цикл выборка-декодирование-выполнение).
*   **Переход к следующему:** После уверенного понимания этих концепций переходите к [[#Этап 1: Язык C - Фундамент|Этапу 1]].

### Этап 1: Язык C - Фундамент
[[Этап 1 - Изучение C]] <!-- Ссылка на отдельную заметку -->

`[Ядро/Последовательно]`

Язык C - это ваш основной инструмент для низкоуровневого программирования. Этот этап **строго следует за [[#Этап 0: Абсолютные Основы|Этапом 0]]**.
*   **Ключевые темы C:** Базовый синтаксис, типы данных (их размер и представление), управляющие конструкции, функции.
*   **Критически важно:** **Указатели** (Объявление, разыменование, адрес. Это критически важно), Массивы и их связь с указателями, Строки в C (как массивы символов).
*   **Управление памятью:** Стековое (Stack), статическое и динамическое (Heap). `malloc`, `calloc`, `realloc`, `free`. Понимание стека и кучи.
*   Побитовые операции (&, |, ^, <<, >>), Структуры и объединения, Препроцессор, Компиляция и компоновка (`gcc`, `clang`). Простые Makefile.
*   **Переход к следующему:** Как только вы начнете активно использовать указатели и динамическую память, вы готовы к [[#Этап 2: Углубление в Память и Отладка в C|Этапу 2]].

### Этап 2: Углубление в Память и Отладка в C
[[Этап 2 - Отладка и Память в C]] <!-- Ссылка на отдельную заметку -->

`[Ядро/Последовательно]`

Этот этап **неразрывно связан с [[#Этап 1: Язык C - Фундамент|Этапом 1]]** и должен осваиваться параллельно с написанием C-кода.
*   **Темы:** Типичные ошибки управления памятью (утечки памяти, переполнение буфера, висячие указатели, использование после освобождения, двойное освобождение).
*   **Инструменты:** Мастерство использования отладчика **`GDB`** (или другим). Изучение команд для просмотра памяти (`x`), регистров, стека вызовов.
*   Инструменты анализа памяти: **`Valgrind`** (для поиска утечек и ошибок памяти).
*   **Дальнейшие пути:** После освоения C и базовой отладки вы можете:
    *   Узнать, как C-код работает на уровне процессора: Перейти к [[#Этап 3: Введение в Ассемблер и Архитектура CPU|Этапу 3 (Ассемблер)]].
    *   Понять, как программы взаимодействуют с операционной системой: Перейти к [[#Этап 4: Основы Операционных Систем|Этапу 4 (ОС)]].
    *   **Эти два этапа ([[#Этап 3: Введение в Ассемблер и Архитектура CPU|Этап 3]] и [[#Этап 4: Основы Операционных Систем|Этап 4]]) можно изучать параллельно друг с другом и после Этапа 2.**

---

### Этап 3: Введение в Ассемблер и Архитектура CPU
[[Этап 3 - Изучение Ассемблера]] <!-- Ссылка на отдельную заметку -->

`[После Ядра]` / `[Параллельно с Этапом 4]`

Изучение языка, на котором "говорит" процессор. Может начаться **после [[#Этап 2: Углубление в Память и Отладка в C|Этапа 2]]** или **параллельно с [[#Этап 4: Основы Операционных Систем|Этапом 4]]**. Углубляет понимание [[#Этап 0: Абсолютные Основы|основ архитектуры]].
*   **Выберите архитектуру:** x86-64 (для ПК) или ARM (для мобильных/встроенных).
*   **Ключевые темы:** Регистры общего назначения и специальные регистры. Основные типы инструкций: перемещение данных (MOV, PUSH, POP), арифметические, логические, сравнения, условные и безусловные переходы, вызов/возврат из функций.
*   **Стек вызовов (Calling Convention).**
*   Просмотр ассемблерного вывода C-кода (`gcc -S`, команда `disassemble` в `GDB`) - связь с [[#Этап 1: Язык C - Фундамент|C]] и [[#Этап 2: Углубление в Память и Отладка в C|отладкой]].
*   **Связь с другими этапами:** Понимание системных вызовов (связь с [[#Этап 4: Основы Операционных Систем|Этапом 4]]) на уровне ассемблера. Необходим для некоторых [[#Этап 6: Встроенные Системы и Аппаратное Взаимодействие|специализаций в Embedded]].

### Этап 4: Основы Операционных Систем
[[Этап 4 - Изучение ОС]] <!-- Ссылка на отдельную заметку -->

`[После Ядра]` / `[Параллельно с Этапом 3]`

Понимание среды, в которой работают ваши программы. Может начаться **после [[#Этап 2: Углубление в Память и Отладка в C|Этапа 2]]** или **параллельно с [[#Этап 3: Введение в Ассемблер и Архитектура CPU|Этапом 3]]**.
*   **Темы:** Процессы (Processes) и потоки (Threads). Разница.
*   **Критически важно:** **Виртуальная память (Virtual Memory):** Как ОС создает иллюзию большого и раздельного адресного пространства для каждого процесса. Страницы памяти (pages).
*   **Системные вызовы (System Calls):** Как пользовательская программа запрашивает сервисы у ядра ОС (чтение/запись файлов, создание процессов, выделение памяти). Примеры системных вызовов (в Linux: `read`, `write`, `mmap`, `fork`, `execve`). Взаимодействие программы с ОС через системные вызовы. Связь с [[#Этап 1: Язык C - Фундамент|функциями стандартной библиотеки C]] и [[#Этап 3: Введение в Ассемблер и Архитектура CPU|выполнением инструкций]].
*   **Связь с другими этапами:** Понимание управления памятью ОС критично для [[#Этап 2: Углубление в Память и Отладка в C|отладки проблем с памятью]]. Основы планировщика и синхронизации важны для [[#Этап 7: Дополнительные и Смежные Темы|параллельного программирования]].

---

### Этап 5: C++ для Системного Программирования
[[Этап 5 - Cpp Системное Программирование]] <!-- Ссылка на отдельную заметку -->

`[Специализация]`

Если ваша цель - высокопроизводительные приложения, игры или более крупные системные проекты. **Требует уверенного владения [[#Этап 1: Язык C - Фундамент|C]] и глубокого понимания [[#Этап 2: Углубление в Память и Отладка в C|работы с памятью]].**
*   **Ключевые темы (с низкоуровневым уклоном):** RAII (Resource Acquisition Is Initialization) и его роль в управлении ресурсами. **Умные указатели** (`unique_ptr`, `shared_ptr`, `weak_ptr`). Понимание модели памяти C++ (как объекты хранятся, vtables для виртуальных функций). Взаимодействие C и C++ (FFI). Шаблоны и их влияние на производительность.
*   Это **опциональный этап**, если только ваша предметная область не требует C++.

### Этап 6: Встроенные Системы и Аппаратное Взаимодействие
[[Этап 6 - Встроенные Системы]] <!-- Ссылка на отдельную заметку -->

`[Специализация]`

Если ваша цель - программирование микроконтроллеров и работы с "железом". **Требует глубокого понимания [[#Этап 1: Язык C - Фундамент|C]].** Часто требует понимания [[#Этап 3: Введение в Ассемблер и Архитектура CPU|Ассемблера для конкретной архитектуры чипа]] и основ [[#Этап 4: Основы Операционных Систем|ОС]] (например, RTOS).
*   **Темы:** Архитектура микроконтроллеров (ARM Cortex-M, AVR, PIC и др.), Работа с периферией (GPIO, UART, SPI, I2C, ADC, DAC), Чтение даташитов (спецификаций на чип), Регистры управления аппаратурой, Прерывания (interrupts), Real-Time Operating Systems (RTOS).
*   Это **опциональный этап**, если только это не ваша конкретная область интересов.

### Этап 7: Дополнительные и Смежные Темы
[[Этап 7 - Дополнительные Темы]] <!-- Ссылка на отдельную заметку -->

`[Продвинуто/Опционально]`

Темы, которые углубляют понимание или расширяют инструментарий. Осваиваются **после крепкого фундамента ([[#Этап 1: Язык C - Фундамент|Этапы 1]]-[[#Этап 4: Основы Операционных Систем|4]])**, а некоторые требуют и [[#Этап 5: C++ для Системного Программирования|знания C++]].
*   **Темы:** Оптимизация производительности (Профилирование кода, Понимание работы кэша CPU, SIMD-инструкции), Параллельное программирование (Потоки, Синхронизация - опирается на [[#Этап 4: Основы Операционных Систем|концепции ОС]], Атомарные операции), Сетевое программирование (Работа с сокетами на низком уровне - опирается на [[#Этап 4: Основы Операционных Систем|системные вызовы]]), Безопасность (Понимание распространенных уязвимостей памяти - опирается на [[#Этап 2: Углубление в Память и Отладка в C|понимание ошибок памяти]]).

---

### Этап 8: Практика, Проекты и Чтение Кода
`[Постоянно]`

Это **не отдельный этап в конце**, а **непрерывная деятельность на протяжении всего обучения**.
*   Начинайте практиковаться с [[#Этап 1: Язык C - Фундамент|C]] и [[#Этап 2: Углубление в Память и Отладка в C|отладки]] как можно раньше.
*   Применяйте знания [[#Этап 3: Введение в Ассемблер и Архитектура CPU|Ассемблера]] и [[#Этап 4: Основы Операционных Систем|ОС]], исследуя, как работают ваши программы "под капотом".
*   Выбирайте проекты, соответствующие вашему текущему уровню и [[#Этап 5: C++ для Системного Программирования|специализации (C++)]] или [[#Этап 6: Встроенные Системы и Аппаратное Взаимодействие|Embedded]].
*   Читайте исходники для углубления понимания (например, код из [[#Этап 1: Язык C - Фундамент|стандартных библиотек C]], [[#Этап 4: Основы Операционных Систем|ядра Linux]] и утилит GNU).

---

## Важные советы (применимы ко всем этапам):

*   Будьте терпеливы и настойчивы.
*   Много практикуйтесь и пишите код.
*   **Мастерски освойте отладчик!** (см. [[#Этап 2: Углубление в Память и Отладка в C|Этап 2]])
*   Не бойтесь читать документацию и исходники - это основной источник глубоких знаний.
*   Общайтесь с сообществом, задавайте вопросы на профильных ресурсах (Stack Overflow, форумы по C/C++, Embedded).